## Building apps using Gradle 
 We hope you already got a basic understanding of what Gradle is and how to use it. In this topic, we will consider the basic structure of the build.gradle file, and then build and run a small application. The knowledge you obtain here can be used for any JVM-based programming language supported by Gradle (e.g. Java or Kotlin).

This article was written using Gradle 6.8.1. There may be some differences for other versions of Gradle. If you have trouble with this article, you can read the comments or just follow the official Gradle doc instead of this.

## Initializing an application
We assume that you already have some experience with the terminal of your operating system and will interact with Gradle using it. First of all, create a new empty folder named what you want (e.g., demo). In this folder, you need to invoke the gradle init command to start initializing a new Gradle-based project. This command will show you a dialogue form to set up the project you need.

In this form, choose application as the type of the project; Java or Kotlin as the implementation language; and org.hyperskill.gradleapp as the project name if you would like to precisely follow our example (but it isn't required). For all other questions, you can choose their default options, since it doesn't matter now.

Below is an example of choosing options.

```
Select type of project to generate:
  1: basic
  2: application
  3: library
  4: Gradle plugin
Enter selection (default: basic) [1..4] 2

Select implementation language:
  1: C++
  2: Groovy
  3: Java
  4: Kotlin
  5: Scala
  6: Swift
Enter selection (default: Java) [1..6] 3

Split functionality across multiple subprojects?:
  1: no - only one application project
  2: yes - application and library projects
Enter selection (default: no - only one application project) [1..2] 

Select build script DSL:
  1: Groovy
  2: Kotlin
Enter selection (default: Groovy) [1..2] 

Select test framework:
  1: JUnit 4
  2: TestNG
  3: Spock
  4: JUnit Jupiter
Enter selection (default: JUnit 4) [1..4]  

Project name (default: demo): org.hyperskill.gradleapp
Source package (default: org.hyperskill.gradleapp): 
```
After the initialization is completed, the project structure will be the following:

```
.
├── app
│   ├── build.gradle
│   └── src
│       ├── main
│       │   ├── java
│       │   │   └── org
│       │   │       └── hyperskill
│       │   │           └── gradleapp
│       │   │               └── App.java
│       │   └── resources
│       └── test
│           ├── java
│           │   └── org
│           │       └── hyperskill
│           │           └── gradleapp
│           │               └── AppTest.java
│           └── resources
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle
```

This structure includes a lot of files we have already considered (settings.gradle, wrapper files, etc). The most important file called build.gradle, which contains tasks and external libraries, is located within the app directory. This folder exists because we've chosen application as the type of the project and the folder represents our application.

There is also the src directory inside app. It contains two sub-directories main and test. This is a quite standard project structure when using Gradle. In our case, the package org.hyperskill.gradleapp has some Java source code (App.java).

If you chose Kotlin as the implementation language, the project structure will be the same except for Kotlin source code files (.kt instead of .java) and kotlin folders instead of java ones.

Please note, it is a good practice for Java and Kotlin projects to include the name of your organization in the path to your source code files as a package name like org.hyperskill. We follow this recommendation too.

## Running the application
If you look at the list of available tasks for managing the project using the command gradle tasks --all, you will see that the list is fairly long. Here is a shortened version of it:

```
Application tasks
-----------------
run - Runs this project as a JVM application

Build tasks
-----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
...
```
You can use the run command to start the application. To do it, just invoke the gradle run command or use a Gradle wrapper script for your OS. This command will build and run the application. Here is an output example:

```
> Task :app:run
Hello World!

BUILD SUCCESSFUL in 623ms
2 actionable tasks: 1 executed, 1 up-to-date
```

As you can see, the autogenerated application can already display a welcome string. If you get a similar result, it means that everything is OK: your application works and Gradle can manage it!

If you look at the project structure again, you will see that it has some new files, including files with bytecode (App.class, AppTest.class). Actually, Gradle built and started the App.class file when we invoked the run command.

Now, let's consider the build file (build.gradle for Groovy DSL or build.gradle.kts for Kotlin DSL) thanks to which we can build our application successfully and run it using Gradle. This file specifies the project structure and adds some tasks and external libraries to the project. We will not present the entire file here, only its main parts.

## Plugins

The plugins section adds some plugins to extend the capabilities of the project: e.g., to add new tasks or properties.

```
plugins {
    // Apply the application plugin to add support for building a CLI application
    id("application")

    // Apply the plugin which adds support for Java
    id("java")

    // Apply the plugin which adds support for Kotlin/JVM
    id("org.jetbrains.kotlin.jvm")
}
```

Here, id is a globally unique identifier, or name, for plugins. Core Gradle plugins are special in that they provide short names, such as "java" or "application".

Basically, plugins for Kotlin and Java know how to build, package, and run tests on the project. The application plugin facilitates creating an executable JVM application.

There is an alternative way to use a plugin in the project. It's more like a legacy way of applying plugins which is not widely used now, but just in case you see it somewhere, here it is:

```
apply plugin: "application"   // for Groovy DSL
apply(plugin = "application") // for Kotlin DSL
```

There are many other plugins already available for you, and you can find them on the official Gradle Plugins page. A large project can use dozens and hundreds of them. Gradle does not limit the maximum number of plugins used in a project.

## Repositories and dependencies
Usually, you don't need to write your program from scratch – you use already written pieces of code, either yours or other developers'. This is where the dependency system comes in handy.

The repositories section declares locations from which dependencies will be downloaded and added to the project.
```
repositories {
    jcenter()
}
```


